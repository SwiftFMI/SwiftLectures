# Лекция №2
--
В тази лекция ще се запознаем с различните езикови структури в `Swift`. Ще говорим за основните запазени думи, операторите и началните езиковите средства, които да ни послужат, когато пишем програми на `Swift`. Ще представим и възможността да пишем отделни функционални фрагменти, които да можем да изпозваме многократно в нашите програми.

Swift предоставя набор от условни оператори като if, guard и switch, използвани за сравнение на стойностите на променливи и извършване на действия спрямо резултата.

На първо място, нека да разгледаме условния оператор, който ни позволява да правим избор и да задействаме различни части от програмата си, в зависимост от това, дали условието, което проверяваме, е вярно или не.

## `if` оператор
В най-простата си форма оператора `if` има само едно условие. Той изпълнява зададените му изрази само, ако условието му е изпълнено (`true`).

```swift
    var temperature = -1
    if temperature <= 0 {
    	print("Много е студено. Облечете се топло.")
    }
```

Кода проверява дали температурата е по-ниска или равна на 0 градуса по целзий. Ако условието е изпълнено, принтираме съобщение, ако ли не - не принтираме нищо, а кодът продължава след затварящата скоба (}) на `if` оператора.

### `else` оператор
Операторът `if` може да предостави алтернативен набор от условия или `else`, за ситуации в които условието на `if` оператора е грешно (`false`). 

```swift
    var temperature = 6
    if temperature <= 0 {
    	print("Много е студено. Облечете се топло.")
    } else {
    	print("Не е чак толкова студено. Защо не облечете тениска?")
    }
```

Винаги точно едно от условията ще бъде изпълнено. Температурата беше повишена до 6 градуса, затова не е толкова студено, че да препоръчаме шал и израза в `else` ще бъде изпълнен.
### `else if` оператор  
Можете да навържете няколко `if` оператора за да проверите допълнителни условия.

```swift
    var temperature = 32
    if temperature <= 0 {
    	print("Много е студено. Облечете се топло.")
    } else if temperature >= 30 {
    	print("Жега е. Да не забравите да си сложите слънцезащитен крем.")
    } else {
    	print("Не е чак толкова студено. Защо не облечете тениска?")
    }
```

Тук беше добавен допълнителен `if` оператор, за да можем да дадем коректна информация при високи температури. Последият `else` оператор остава, както до сега и ще принтира информация, когато температурите не са нито прекалено високи, нито прекалено ниски.

Последният `else` оператор не е задължителен и може да бъде пропуснат, ако всички условия не трябва да бъдат проверявани.

```swift
    var temperature = 24
    if temperature <= 0 {
    	print("Много е студено. Облечете се топло.")
    } else if temperature >= 30 {
    	print("Жега е. Да не забравите да си сложите слънцезащитен крем.")
    } 
```

Поради причината, че температурата не е нито твърде ниска, нито твърде висока, за да задейства `if` или `else if` операторите, няма да бъде принтирано никакво съобщение.

## Условен оператор `switch`
`switch`операторът проверява стойността на променлива и я сравнява с различни възможни варианти, а след това изпълнява изразите, принадлежащи на първото съответствие. `switch`-ът е алтернатива на `if` оператора, която е предназначена за работа с голям брой възможни съвпадения.
В най-простата си форма `switch` операторът сравнява стойност с една или повече стойности от същият тип.

```swift
    switch стойност за проверка {
    case стойност 1:
    	отговор за стойност 1
    case стойност 2, стойност 3:
    	отговор за стойностите 2 и 3
    default:
    	в противен случай, изпълни друг израз
    }
 ```

`switch` операторът съдържа в себе си различни възможни съответствия (`case`). Освен сравнението със специфични променливи, `switch` операторът може да бъде използван за сравнение с по-сложни изрази.
Всеки `case` бива сравняван със зададената, с инициализацията на `switch`-a, променлива. Ако условието е изпълнено (`true`), се изпълнява набора от изрази, зададени в тялото на съответният `case`. В тялото на всеки дефиниран `case` трябва да има поне един изпълняем израз.
Всеки `switch` трябва да бъде изчерпателен. Всяка възможна стойност на променливата, която се проверява, трябва да бъде описана в `case`. Ако това не е възможно, може да бъде дефиниран основен (`default`) `case`, за да могат да бъдат покрити всички останали стойности, които не са описани в отделен `case`. `default` `case`-ът се намира винаги в края на `switch` оператора.

```swift
    let someNumber: Int = 3
    switch someNumber {
    case 1:
        print("Едно")
    case 3:
        print("Три")
    default:
        print("Някакво друго число")
    }
```

В този пример ще бъде сравнявано число от тип `Int`, наречено `someNumber`. В първия случай (`case`) `someNumber` ще бъде сравнено с числото 1, а във втория - с 3. Тъй като не можем да сравним `someNumber` с всички възможни числа, използваме `default` `case`, за да покрием останалите числа, които не сме изброили в отделни `case`-ове. По този начин се уверяваме, че `switch` операторът е изчерпан.
В повечето езици, като `C` и `Objective-C`, изпълнението на кода след проверката на `case` продължава към следващия `case` до прекратяване чрез `break`. Вместо това, в `Swift` `switch` операторът прекратява изпълнението си след първото съвпадение без нуждата да бъде спряно чрез `berak`. Това прави използването на оператора по-лесно и безопасно, избягвайки възможността да се изпълни повече от един `case` по грешка. И все пак, това поведение може да бъде избегнато, като използваме запазената дума `fallthrough` в края на избран или всеки описан `case`.

В един `case` можем да сравняваме повече от един случай. В примера по-горе можем да комбинираме използваните случаи 1 и 3 в един `case`, като ги разделим чрез запетая.

```swift
    let someNumber: Int = 3
    switch someNumber {
    case 1,  3:
        print("Едно или три")
    default:
        print("Някакво друго число")
    }
``` 
### Сравнение с последователности
Стойността на сравняваната променлива може да бъде сравнена и с диапазон.

```swift
    let count = 34
    let things = "ябълки"
    var expression: String
    switch count {
    case 0:
        expression = "николко"
    case 1..<10:
        expression = "няколко"
    case 10..<100:
        expression = "десетки"
    case 100..<1000:
        expression = "стотици"
    default:
        expression = "много"
    }
    print("\(count) са \(expression) \(things)")
```

В примера константата `count` се сравнява с число или диапазон от числа. Тъй като стойността на `count` се намира между 10 и 100, `expression` заема стойността на `“десетки”` и изпълнението излиза извън `switch` оператора, като принтира `“34 са десетки ябълки”`.
### Сравнение на няколко стойности (n-торки)
В един `switch` можем да сравним стойностите на повече от една променлива. Стойността на всяка подадена променлива може да бъде сравнена с друга стойност или диапазон от стойности. А всяка стойност в `case` може да бъде заместена с долна черта (`_`), позната като маска, която ще съвпадне с всяка подадена стойност.
В примера ще проверим дали по дадена точка `(x, y)` в координатната система, изразена чрез `(Int, Int)`, се намира в квадрат 4 на 4, средата на който се намира в точка `(0, 0)`.

```swift
    let point = (1, 1)
    switch point {    
    case (0, 0):
        print("точка (0, 0) е в началото на координатната система")
    case (_, 0):
        print("точка (\(point.0), 0) се намира на абсциса х")
    case (0, _):
        print("точка (0, \(point.1)) се намира на абсциса у")
    case (-2...2, -2...2):
        print("точка (\(point.0), \(point.1)) е в квадрата")
    default:    
        print("точка (\(point.0), \(point.1)) е извън квадрата")
    }
```

Този `switch` оператор проверява, дали подадената точка се намира: в началото на координатната система, на абсциса х, на ордината у, в квадрат 4 на 4 или извън него. Ако бе подадена точка `(0, 0)`, щяхме да имаме 3 съвпадения, тъй като първите 3 case-a отговарят на подадената стойност. В такъв случай, първата проверка (`case (0, 0)`) щеше да бъде изпълнана, което ще прекрати изпълнението на `switch`-a и всички останали проверки щяха да бъдат игнорирани.

### Присвояване на стойност
Стойността или стойностите на `case` могат да бъдат присвоени във временна константа или променлива, която да се използва в тялото на случая (`case`). В следващия пример ще подадем точка `(x, y)` и ще категоризираме позицията й върху координатната система.

```swift
    let point = (0, 1)
    switch point {
    case (let x, 0):
        print("точка (\(x), 0) се намира на абсциса х")
    case (0, let y):
        print("точка (0, \(y)) се намира на ордината у")
    case let (x, y):
        print("точка (\(x), \(y)) е някъде другаде")
    }
```

В примера проверяваме дали подадената точка се намира на абсциса х, ордината у или някъде другаде. В дефинираните случаи (`case`) проверяваме една от точките, а другата я присвояваме към временна константа. След като временната константа е дефинирана, тя може да бъде използвана в тялото на `case`-a, в този случай я използваме, за да принтираме нейната стойност.
Както виждате, в примера няма `default` `case`. Последният случай (`case let (x, y):`) присвоява и двете подадени стойности, което позволява съвпадението с всяка подадена точка. Тъй като `point` съдържа винаги 2 стойности, последният случай (`case`) ще съвпадне с всички останали възможни стойности и `default` `case`-a не е нужен, за да изчерпим този `switch` `case`.

## Цикли

### Цикъл for in
Можете да използвате цикъла `for in`, за да обиколите елементи в масиви, символи в низ или диапазон от числа.
Този пример принтира първите няколко вписвания в масив от 5 числа.

```swift
    for index in 1...5 {
        print("\(index) по 5 е \(index * 5)")
    }
```

В примера се създава диапазон от числата (от 1 до 5) чрез използването на оператора за затворен диапазон (`...`). Стойността на `index` се задава от първото число в диапазона (1) и изразите в цикъла биват изпълнени. В този случай, цикълът съдържа само един израз, който принтира текущата стойност на `index`. След като изразът бъде изпълнен, стойността на `index` се обновява, така че да съдържа следващата стойност от зададеният диапазон (2) и `print` функцията се задейства отново. Този процес се повтаря до края на диапазона.
В примера по-горе `index` е константа, която автоматично се задава в началото на всяка итерация от цикъла. Поради тази причина не е нужно `index` да бъде деклариран преди да бъде използван. Задава се просто чрез включването му в декларацията на цикъла без използването на запазената дума `let`.

Ако не Ви е нужно да използвате стойността на променливата в цикъла, можете да игнорирате стойността й чрез използването на долна черта на мястото на името на променливата.

```swift
    let base = 3
    let power = 10
    var answer = 1
    for _ in 1...power {
        answer *= base
    }
    print("\(base) на степен \(power) е \(answer)")
```

Примерът горе изчислява стойността на едно число на степентта на друго (в този случай: 3 на степен 10).  Това умножава началната стойност 1 (пропускаме 3 на степен 0) по 3, десет пъти, използвайки затворен диапазон започващ с 1 и завършващ с 10. За това изчисление не е нужна стойност за отброяване на пътите, в които е преминато през израза в цикъла, кодът просто се изпълнява правилният брой пъти. Долната черта (`_`) се използва на мястото на променливата в цикъла, което ни позволява да игнорираме индивидуалните стойности на променливата по време на изпълнението му.

Можете да използвате `for in`, за да обиколите елементите в масив.

```swift
    let names = ["Емил", "Спас", "Иван", "Гошо"]
    for name in names {
        print("Здравей, \(name)!")
    }
```

Също така можете да обикаляте масиви с ключ и стойност (dictionary), за да достъпите двойките ключ-стойност. Всеки елемент от масива се връща като (key, value) при всяка итерация на масива. Можете да декомпозирате стойностите на (key, value) с различни имена, които да използвате в изразите на цикъла. В примера ключовете на масива са декомпозирани в константи, наименовани `animalName`, а стойностите - `legCount`

```swift
    let numberOfLegs = [“паяци”: 8, “мравки”: 6, “котки”: 4]
    for (animalName, legCount) in numberOfLegs {
        print("\(animalName)те имат \(legCount) крака”)
    }
```

Не е нужно елементите в dictionary да бъдат итерирани по реда, в който са вкарани. Съдържанието на dictionary не е подредено и когато го обхождаме, нямаме гаранция за реда, в който ще бъдат върнати стойностите му.

### Цикли тип while
`while` цикълът изпълнява набор от изрази, докато условието му не стане `false`. Този вид цикли се използват, когато не се знае колко пъти трябва да се изпълни даден израз преди началото на първата итерация. `Swift` предлага два вида `while` цикли:
`while`, който проверява условието в началото на всяка итерация на цикъла
`repeat while`, който проверява условието в края на всяка итерация на цикъла
#### while
`while` започва, като проверява едно единствено условие. Ако условието е вярно (`true`), набор от изрази се повтарят, докато условието стане грешно (`false`).
Това представлява един типичен `while` цикъл:

```swift
    while условие {
    	изрази
    }
```

В този пример ще използваме играта “Змии и стълби”.

Правилата са следните:
Игровата дъска съдържа 25 квадрата и целта на играта е да се достигне или премине 25-тият квадрат;
Всеки ход играча хвърля зар и премества своята пионка според числото, което е хвърлил. Посоката на преместване се определя по поредността на номерата изписани на дъската;
Ако ходът Ви завърши в началото на стълба, трябва да се качите по нея;
Ако ходът Ви завърши на главата на змия, трябва да слезете до опашката й.

Игровата дъска ще бъде представлявана от масив с елементи от тип `Int`. Големината на дъската (броят квадрати) ще зависи от константа `finalSquare`, която ще се използва за инициализация на масива и за да проверим дали има победител по-късно. Дъската ще бъде инициализирана с 26 нули от тип `Int`, а не 25 (от 0 за начална позиция до 25).

```swift
    let finalSquare = 25
    var board = [Int](repeating: 0, count: finalSquare + 1)
```

Някои квадрати ще бъдат с различна стойност от 0, които ще представляват змиите и стълбите. Квадратите със стълби ще имат позитивни стойности, за да отведат играча по-нагоре по дъската, а квадратите със змийски глави ще съдържат негативни стойности, за да върнат играча назад по дъската.

```swift
    board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
    board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
```

Квадрат 3 съдържа долната част на стълба, която ви отвежда до квадрат 11. За да представим това, `board[03]` ще бъде равен на +08, което е еквавилент на integer стойността 8 (разликата между 3 и 11).
Играчът започва от квадрат 0, което е точно до долният ляв ъгъл на дъската. Първото хвърляне на зара винаги премества пионката на играча върху дъската.

```swift
    var square = 0
    var diceRoll = 0
    while square < finalSquare {
        // хвърляне на зар
        diceRoll += 1
        if diceRoll == 7 { diceRoll = 1 }
        // преместване спрямо стойността на зара
        square += diceRoll
        if square < board.count {
            // ако пионката на играча все още е върху дъската, преместваме     пионката нагоре или надолу за змия или стълба
            square += board[square]
        }
    }
    print(“Край на играта!”)
```

Примерът горе използва доста опростен вариант за хвърляне на зар. Вместо да генерираме случайно число, `diceRoll` винаги започва със стойност 0. При всяка итерация на цикъла `diceRoll` се инкрементира с единица, а след това се проверява дали стойността не е станала прекалено голяма. Когато стойносттна й достигне 7, стойността на зара е станала прекалено голяма и се връща до 1. Като резултат стойностите на зара стават 1, 2, 3, 4, 5, 6, 1, 2 и така нататък.
След като зарът е хвърлен, пионката на играча се придвижва напред според стойността на `diceRoll`. Възможно е хвърлянето да отведе играча на по-горна позиция от 25-тия квадрат, което значи край на играта. За да можем да изпълним този сценарий, кодът проверява дали square е с по-ниска стойност от броя на елементи на board преди стойността на елемента в `board` да бъде добавена към текущата стойност на square, което ще придвижи играча според това дали е попаднал на змия или стълба.
След това текущата итерация на цикъла завършва и зададеното условие се проверява отново, за да се разбере дали е нужна следваща итерация. Ако играчът е стъпил или преминал квадрат 25, проверката на условието ще доведе до `false` и играта ще приключи.
Цикълът `while` е подходящ в този пример, защото продължителността на играта не е ясна преди началото на цикъла, а вместо това цикълът се изпълнява докато условието не е задоволено.

#### Цикли тип repeat while
Другият вариант на цикъла `while` (или цикъл `repeat while`) изпълнява първоначална итерация на цикъла преди да провери условието. След това продължава да изпълнява цикъла докато условието не стане грешно (`false`). 
`repeat while` в `Swift` е аналог на `do while` цикъла в други езици.
Това представлява един типичен `repeat while` цикъл:

```swift
    repeat {
        изрази
    } while условие
```

Ето същия пример на “Змии и стълби” реализиран с `repeat while` цикъл. Стойностите на `finalSquare`, `board`, `square`, и `diceRoll` се задават по същият начин както в `while` цикъла.

```swift
    let finalSquare = 25
    var board = [Int](repeating: 0, count: finalSquare + 1)
    board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
    board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    var square = 0
    var diceRoll = 0
```

В този вариант на играта първото нещо, което се изпълнява в цикъла е да се провери за змия или стълба. Няма стълба на дъската, която да отведе играча директно до 25тият квадрат, затова не е възможно да се спечели играта докато се изкачва стълба. Следователно е безопасно да се провери за змия или стълба още в първият израз в цикъла.
В началото на играта играча е на квадрат 0. `board[0]` винаги е равен на 0 и няма никакъв допълнителен ефект.

```swift
    repeat {
        // преместване спрямо стойността на зара
        square += board[square]
        // хвърляне на зара
        diceRoll += 1
        if diceRoll == 7 { diceRoll = 1 }
        // преместване спрямо стойността на зара
        square += diceRoll
    } while square < finalSquare
    print("Край на играта")
```

След като кода провери за змии или стълби, зарът се хвърля и играча се мести напред с брой квадрати равен на стойността на `diceRoll`. След това текущата итерация на цикала приключва.
Условието на цикъла (`while square < finalSquare`) е същато, като в предният пример, но този път не се проверява докато не се изпълни първата итерация. Структората на `repeat while` е по-подходяща за тази игра от `while`. В `repeat while` цикъла, `square += board[square]` се изпълнява винаги след като е проверено, че `square` все още е на дъската. Това поведение ни дава възможността да премахнем проверката `square < board.count` от предният пример.

 
Нека сега да представим и възможността за дефиниране на преизползваеми фрагменти от програми, които можем да позлваме многократно.
