# Лекция №7
--

В тази лекция ще разгледаме общия вид на функциите - closures. Ще започнем с кратък преговор на това, което знаем за функциите и ще се впуснем в детайли за closure-ите.

## Какво са функциите?

Функциите са блок от код, които може да се употреби (активира) на различни места в нашата програма. Една функция има параметри, от които зависи и може да връща резултат. Т.е. функцията в общия вид е действие над определени данни (параметри), което има резултат.

Това е съществено, за да можем да разберем, че функциите имат и определен тип. Т.е. следните две функции са от един тип.

```swift
func sum(a:Int, b:Int) -> Int {
    return a + b
}
	
func product(a:Int, b:Int) -> Int {
    return a * b
}
```

### Функциите като тип

Всяка функция има определен тип, който се формира от типа на параметрите и от типа на резултата, връщан от функцията. Т.е. типа данни, над които ще работи и типа на резултата формират цялостния тип на функцията. (Има паралел с tuples от гледна точка на това, че самият тип е съставен от няколко части, но пък функцията съдържа и закодирана последователност от действия).

Типът на функциите от примера по-горе е `(Int, Int) -> Int`.

Имайки възможността да обединяваме различни функции по тяхния тип, ние можем да пишем програми, в които да заместваме дадени фукции една с друга. Всичко това може да става динамично, а кодът, който борави с тях, да е лесен, компактен и в обща форма. 

Примерно: Ако разработваме приложение, което реализира софтуерен калкулатор, при натискане на бутон с операция (x, /, ^, +, -) ние можем да запомним вида на операцията (най-често бинарна операция от вида `(Int, Int) -> Int`). Tака няма да навлизаме над детайли какви операции ще има конкретно калкулатора при реализиране на логиката за изчисление, а ще можем да подходим абстрактно.

Типът на функция е пълноправен тип данни. Използваме го както останалите типове. Можем да имаме, променливи, константи, параметри от такъв тип и функциите могат да връщат резултат от такъв тип. Т.е. можем да подаваме функция като параметър и да връщаме резултат, който да е функция.

Ето и един пример как функция може да взима друга като параметър:

```swift
func printAllNames(names: [String], printFunc: (String) -> Void) {
    for name in names {
        printFunc(name)
    }
}
```
Вторият параметър е от тип `(String) -> Void`. Това е типът на функция, която има един параметър и не връща резултат.

А това е пример как дадена функция може да връща функция като резултат:

```swift
//: Да се даде пример за функция, която връща функция като параметър.

func createVeryFancyPrintFunction() -> (String)-> Void {
    
    func fancyPrint(name: String)   {
        print("@****************************@")
        print("@$$$$$$$$$$ \(name) $$$$$$$$$@")
        print("@****************************@")
    }
    
    
    return fancyPrint
}
```
Типът на връщаната функция е `(String) -> Void`. Интересното е, че декларираме функция във функция. Това се нарича вместване на функции. Функции, които са част от други функции, се наричат nested (вместени).

### Nested (вместени) функции

До сега сме се запознали с функции, които са глобални (методите, които са част от класовете, са по-различен вид функции, които познаваме). Вместените функции са такива функции, които се появяват като част от тялото на друга функция. Ето и един пример:

```swift
func globalFunc() {
    var divisor = 3
    
    func nestedFunction(i: Int) -> Bool {
        print("\(i) is printed from the nested function");
        //как можем да ползваме променлива от външната функция?
        return i % divisor == 0
    }
    //извикване на вместената функция (calling the nested function)
    nestedFunction(i: 5)
}

//извикване на глобалната функция
globalFunc()
//вместената функция не е видима тук и следващият ред предизвиква компилационна грешка
//nestedFunction(3)
```

Припомняйки какво бяха функциите, ние се запознахме с един комплексен тип данни - типа на дадена функция и възможността да влагаме функции (nested функциите). Сега ще престъпим към дефинирането на общия вид на клоужърите.

## Closures (Клоужъри)

### Какво са клоужърите?

В Swift, клоужърите (closure) са:

* глобалните функции с имена, които вече познаваме;
* вместените функции са клоужъри, които имат видимост до променливите в функцията, която ги съдържа (процеса по запомняне/прихващане на променливите се нарича capturing)
* клоужър израз - без име, записан по специфичен начин, прихващащ (capture) стойности от прилежащия му контекст.

Клоужърите имат прост и компактен синтаксис. Ще го видим в различни примери, които следват. Техният механизъм позволява определянето на типовете на параметрите автоматично и на връщания резултат. Ако имаме клоужър само с един израз, тогава не е нужно да използваме `return`, за да обявим, че връщаме резултат. 
Клоужърите имат съкратен вариант и в него можем лесно да се обръщаме към параметрите.


Клоужърите могат да се подават като последен параметър към функция. В този случай можем да ги изписваме в къдрави скоби след функцията, като изпуснем последния параметър.

```swift
func trailingClosure(i:Int, predicate: (Int)->Bool) {
    print("Проверка за \(i)")
    if predicate(i) {
        print("Предикатът е удволетворен.")
    }
}
```

Тук имаме дефинирана функция, чийто втори параметър е от тип функция (клоужър) `(Int) -> Bool`. Ще използваме експлицитно извикване на тази функция, като винаги ще подаваме еквивалентен клоужър по функционалност, но записан по различен начин.

```swift
//нормалното извикване
trailingClosure(i: 1, predicate: { (a) -> Bool in
    return a % 2 == 0
})

//няма нужда от определяне на типа, който връща клоужъра, той може да бъде определен автоматично
trailingClosure(i: 1, predicate: { (a) in
    return a % 2 == 0
})

//клоужърът е последен параметър, затова се подава като блок код след извикване на функцията
trailingClosure(i: 4) { (a) in
    return a % 2 == 0
}

//съкратен вид
trailingClosure(i: 4) { (a) in
    //без return понеже имаме само един ред
    a % 2 == 0
}

//подразбиращи се имена на параметрите
//кодът е къс, но трудно разбираем за всички
trailingClosure(i: 8) {
	//използваме автоматичното име, за да достъпим първия аргумент на клоужъра
    $0 % 2 == 0
}
```
Когато нямаме явни имена на параметрите, не трябва да използваме запазената дума `in`. 

Имената на параметрите следват следния шаблон - започват с `$` и следва число. Индексирането е от `0`. За да достъпим първия параметър, подаден на клоужър, трябва да използваме `$0`.

Ето и нещо любопитно: как можем да използваме оператор, за да сортираме масив от данни.

```swift
let names = ["aaa", "ccc", "bbb"]
//сортиране
print(names.sorted(by: { $0 > $1 }))
print(names.sorted() { $0 > $1 })
//сортираме, като подаваме функция от тип (String, String) -> Bool ( т.е. оператор за сравнение)
print(names.sorted(by: >))
```

### Какво е capturing (запомняне/прихващане)?

Това е процес, при който става запомняне на контекста, в който възниква даден клоужър (closure). В примера по-горе nested (вместената) функция прихваща променливата `divisor`. Прихващането позволява използването на такива променливи или константи в тялото на фукцията по всяко едно време. Ето и един по-комплексен пример, който можем да използваме за генератор на четните числа.

```swift
//пример за запомняне на променливи от контекста (JS програмиране)


func createGen(start: Int, modify: @escaping (Int) -> Int ) -> ()->(Int) {
    
    var myStart = start
    
    return {
        myStart = modify(myStart)
        return myStart
    }
    
}

var next = createGen(start: 0) {
    $0 + 2
}

print(next()) //2
print(next()) //4
print(next()) //6
print(next()) //8
```
Не трябва да забравяме, че клоужърите са референтен тип.
Важно е да отбележим, че компилаторът очаква всеки клоужър (подаден като аргумент) да не напуска тялото на функцията, към която е подаден. Но това не винаги е правилното нещо. Затова ние можем да маркираме параметър от тип функция(клоужър) като `@escaping`.

Ето и един кратък пример, който показва как дадена функция може да напусне границите на друга, към която е подадена.

```swift
var handlers:[()->Void] = []
//трябва да добавим атрибута @escaping иначе няма да се компилира
func escapingClosure(f: @escaping ()->Void) {
    handlers.append(f)
}

handlers.append {
    print("test")
}

escapingClosure {
    print("test 2")
}

//активираме всички функции
for f in handlers {
    f()
}
```

Възможно е да маркираме даден аргумент като `@autoclosure`. Това ще ни позволи да подадем код, който автоматично ще бъде превърнат във функция. Активацията ще настъпи в правилното време, когато параметърът бива активиран с нужните параметри. В конкретния случай само извиква `pred()`.

```swift
func funcAutoclosure(pred: @autoclosure () -> Bool) {
    if pred() {
        print("It's true")
    } else {
        print("It's НОТ true")
    }
}

funcAutoclosure(pred: 11 > 12)
funcAutoclosure(pred: { () -> Bool in return 2 > 1}())

//допълнителен пример
func funcAutoclosureComplex(pred: @autoclosure () -> ()) {
    print("body of \(#function)")
}


func funcAutoclosureComplexVoid(pred:()) {
    print("body of \(#function)")
}

funcAutoclosureComplex(pred: print("the function is wrapped in a closure and it's never called."))

funcAutoclosureComplexVoid(pred: print("the function print() is called"))
//Това е изходът от горния код:
//body of funcAutoclosureComplex(pred:)
//the function print() is called
//body of funcAutoclosureComplexVoid(pred:)
```

Възможно е да комбинираме и двете анотации `@escaping` и `@autoclosure`. Ето и един пример, който показва това:

```swift

//: () и Void са еквивалетни записа за липсата на резултат
var predicates:[()->Void] = []
func funcEscapeAutoclosure(pred:@escaping @autoclosure () -> ()) {
    predicates.append(pred)
}

funcEscapeAutoclosure(pred: print("body 2"))
funcEscapeAutoclosure(pred: print("body 3"))
funcEscapeAutoclosure(pred: print("body 1"))
//няма да има нищо отпечатано на екрана, понеже  функцията print() е вкарана автоматично в closure, но той не е извикан.

```

Трябва да запомним че `@autoclosure` ни задължава да изпозлваме нормален код вместо функция и `Swift` ще "опакова" този код в функция, която може да бъде оценена по-късно.