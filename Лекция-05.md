# Лекция №5 
--
В тази лекция ще разгледаме класовете и ще ги съпоставим с наученото за структурите. Ще въвдем основните принципи на обектно-ориентираното програмиране (ООП).

## Въпроси от предишната лекция

Следват няколко основни въпроса, които маркират ключови моменти от предишната лекция.

- Какви видове са структурите?
- Какви видове пропъртита знаем?
- Какво са `init` методите?
- Какво е `subscript`?
- Как можем да променяме части от структурата?
- Какво е предимството на `lazy`?

## Класове

Към момента познаваме основните типове от данни като `Int`, `Double`, `Bool`, `Float`, `String`, изброимите типове, колекциите (`Array` и `Dictionary`) и структурите като тип в Swift. Всички тези типове са типове, които се предават по стойност (за повече информация, разгледайте [лекция 4](./2018-03-22-Swift-4-Лекция-4.md)).

Днес ще се запознаем със значително по-различен тип данни, които имат различно поведение. Класовете и типовете, които ще дефинираме на базата на тях се наричат референтни типове. Ще стане ясно какво е характерно за тях и какви са основните разлики с типовете, предавани по стойност. 

За да декларираме собствен клас (тип данните), ние използваме запазената дума `class`. После даваме име на типа данни, което трябва е уникално. Прието е имената на класовете да започват с голяма буква, тъй като декларираме тип данни, подобен на `Int` или `String`. 

Ето и един клас:

```swift
class Media {
	var name: String = ""
	var sizeInBytes: Double = 0.0
}
```

Очевидната разлика между класовете и структурите е в запазената дума.

Както и при структурите, така и тук можем да говорим за обекти от дефинирания тип, само когато направим променлива и я инициализираме, използвайки класа. Това изглежда така:

```swift
let movie = Media()
movie.name = "X-Men"
print("Media name: \(movie.name)")
```

Използваме пропъртитата (член данните), използвайки точковата нотация, както и при структурите.

_Интересно е, че ако опитаме да сменим типа от клас на структура, тогава кодът няма да работи. Причината за това се крие в разликата между референтните и стойностните типове._

Ако имаме структура и направим константа, в която съхраним обект от тип структура, тогава не можем да модифицираме пропъртитата, независимо от това какви са те - `var` или `let`. 

Това, обаче, не е вярно за класовете (виж примера по-горе). Нека си представим, че константата е свързана с точно конкретно място в паметта, но тази част от паметта (понеже е обект от референтен тип) сочи клетка, която може да се променя. 

Малко по-различно стоят нещата при структурите - константа съдържа директно копие на всички полета и така те не могат да бъдат променяни.

Какво още можем да научим за референтните типове?

* Само когато създаваме нов обект, се заделя ново място в паметта. 
* Когато имаме присвояване на променливи, тогава се получава само едно свързване на променливата с мястото в паметта, където се намира обекта.

Пример:

```swift
let ref = movie
print("Media ref name: \(ref.name)")
movie.name = "X-Men 2"
print("Media ref name: \(ref.name)") 
	
//Media name: X-Men
//Media ref name: X-Men
//Media ref name: X-Men 2
```

При структури щяхме да имаме една и съща стойност за `ref.name`.

За разлика от структурите, при класовете е възможно в няколко променливи да има един и същ обект. (Променливите или константите да сочат към едно и също място в паметта) За да можем да сравним две променливи и тяхните референции (места към които съхраняват), е въведен операторът за идентитет `===` (identical to) и съответно - допълващият го `!==`.

Трябва да правим разлика между оператора `==`за еквивалентност, който е приложим над структурите (__но трябва да си го дефинираме__) и оператора за идентитет `===`, който е приложим над класовете.

Преди да преминем към детайли относно класовете е добре да знаем кога следва да позлваме структури и кога класове.

Целта на структурите е да представяме малки обеми от данни в паметта. Такива, които ще бъдат копирани при всички действия. Добре е да изпозлваме структура, ако всички полета са структури. Когато смесваме структури с класове, е доста трудно да проследим закономерността - какво става при копиране. А какво става, когато имаме константа? Следва пример, който скицира проблема:

```swift
var newMediaList2 = mediaList
//това работи, понеже newMediaList2 е променлива
newMediaList2.count = 5
//това също работи
newMediaList2.item.name = "X-Men 2.5"
	
let constMediaList = mediaList
//това също работи
constMediaList.item.name = "X-Men 3"
```

Ако имаме поведение, което трябва да е споделено между различни типове и то трябва да се определя в наследниците, тогава трябва да предпочетем клас пред структура. Ако нямаме нужда от наследяване, тогава се спираме на структури.

Класовете ни дават пълна свобода и могат да се използват във всички случаи. Ако сме наясно, че можем да използваме структура, тогава е удачно да я използваме вместо клас.


## Наследяване

Наследяването е механизъм, който може да се прилага над класовете. Той позволява споделянето на характеристиките (пропъртита, методи и други) от базови класове към наследници. Той е основната причина да има __полиморфизъм__ - динамично определяне коя функция трябва да бъде извикана в зависимост от типа на обекта. Ще стане ясно, когато разберем повече как можем да предефинираме методи и пропъртита.

### Какво е базов клас?

Базовият клас е клас, който не наследява други класове. Базов е, защото основава нова йерархия. Той може да бъде наследяван.

В Swift, ако не е посочен базов клас в клас дефиниран от нас, то няма подразбиращ се базов клас, от който всички типове произхождат. Разлика с Java - `Object` (https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html).


```swift
enum Color {
	case pink
	case green
	case black
	case blue
	case white
	case noColor
}

//базов клас
class Show {
	var name: String
	var color: Color
	var country: String
	var language: String
	var duration: Double
	    
	init() {
		self.name = " no name "
		color = .noColor
		self.country = "no country"
		language = "BG"
		duration = 0.0
	} 
	
	var durationInMinutes:String {
		let minutes:Int = Int(round(duration))
		let minutesInHour = 60
		return "\(minutes / minutesInHour) : \(minutes % minutesInHour) min"
	}
	
	func shortDescription() -> String {
		return "\(name) - \(language) :  Duration: \(durationInMinutes)"
	}
	
	deinit {
		print("deinit \(#function)" )
	}
}
	
extension Show {
	convenience init(duration:Double) {
		self.init()
		self.duration = duration
	}
}
```

Тук дефинираме клас наследник на `Show`, който се казва `TVShow`. Той има допълнително пропърти `series` - брой епизоди.

Определяме, че един клас наследява друг, като изписваме ` : Името на базовия клас` след името на класа. В нашия случай, `class TVShow : Show`.

__Всеки клас може да има само един клас, който да наследява.__
__Ако не наследява нито един клас, тогава този клас е базов.__
Всеки клас, който може да бъде наследен (по-късно ще изясним как можем да предотвратим наследяването), може да бъде наследен безброй пъти. Т.е. нямаме ограничение колко пъти един клас, който може да бъде наследен, ще бъде наследен.


```swift
class TVShow : Show {
	var series: Int
	
	override init() {
		series = 0
		//извиква конструиращия метод на бащиния клас
		super.init()
	}
	
	init(name:String) {
		series = 0
		//извиква конструиращия метод на бащиния клас
		super.init()
		super.name = name
	}
	    
	var isTurkish:Bool {
		return self.language == "TR" && self.series > 100
	}
	    
	override func shortDescription() -> String {
		return super.shortDescription() + " v.2"
	}
	    
	deinit {
		print("deinit TVShow" )
	}
}
```	
В класовете наследници можем да добавяме допълнителни полета, стига те да не се препокриват с тези, които получаваме наготово от наследения клас. 

Например
: Ако в `TVShow` добавим `duration`, тогава компилаторът ще ни подскаже, че това не е възможно, тъй като базовият клас съдържа такова пропърти.

Ето и как можем да използваме класа `TVShow`.


```swift
var blackSails:TVShow = TVShow(name: "Balck Sails", duration: 123)
print(blackSails.shortDescription())
//създаваме нов обект и старият бива деинициализиран
blackSails = TVShow()
```

### Инициализатори 

Всеки тип (клас или структура) трябва да има инициализиращ метод, който се грижи за инициализирането на паметта. Както дискутирахме при структурите и тук важат правилата за инициализаторите (конструктoрите), но с малки разлики. Инициализаторите (`init` методите) трябва те да се грижат да попълнят всички полета, които изграждат класа или структурата. Не е нужно да се инициализират полетата, които имат стойност по подразбиране. Optional (опционалните) полета имат стойност по подразбиране, която е - "липсата на стойност" или `nil`.

При класовете, получаваме конструктор по подразбиране (т.е. без никакви параметри). При структурите освен този, получаваме и конструктор по всички полета, който можем да използваме, за да инициализираме всички полета с нови данни. Ето и един пример, който илюстрира автоматично генерираните методи.

```swift
struct StructBook {
	var pageCount = 0
	var title = "no title"
	var publishDate:Date? = nil
}
	
class Book {
	var pageCount = 0
	var title = "no title"
	var publishDate:Date? = nil
}
	
var book = Book()
book.pageCount = 100
	
var book2 = StructBook(pageCount: 1000, title: "Swift 3", publishDate: nil) 
```


Понякога ще ни трябва повече от един конструктор. И преди да се втурнем към директното имплементиране, е добре да знаем, че има два основни типа конструктори.

Основните конструктори са тези, които се грижат за конструиране на обекта. Известни са в литературата като ```designated```. Характерното за тях, е че се грижат напълно за инициализирането на обекта от даден тип. Т.е. няма поле, което да не е инициализирано и да не се знае каква стойност ще има.

Другият тип конструктори е "удобните" `convеnience` конструкторите [convenient - удобен, пригоден, подходящ]. Те се маркират с тази запазена дума.

Пример:


```swift
class Book {
	var pageCount = 0
	var title = "no title"
	var publishDate:Date? = nil
	    
	convenience init(pages:Int) {
		self.init()
		self.pageCount = pages
	}	    
}
```


Тези конструктури са задължени да извикват директно или индиректно един основен конструктор. "Удобните" конструктори трябва да делегират конструирането на обекта на друг основен конструктор или могат да делегират на друг "удобен", но винаги един от "удобните" конструктори трябва да се обръща към основен конструктор.

Добра практика е да се дефинират допълнителни конструктури, но те да се добавят в `extension`. Трябва да знаем, че __можем__ да дефинираме само "удобни" конструктори в разширението. Ако искаме да добавим основен конструктор, то трябва да допишем неговата дефиниция в началната (основната) дефиниция на типа данни (клас или структура).
Трябва да ни е ясно, че всеки тип данни трябва да има поне един основен конструктор, който да може да се използва за конструирането на обекти.

#### Задължителни конструктори

Ако обявим един конструктор със запазената дума `required`, то всеки един наследник трябва да го имплементира.

(виж протоколи) Ако конструктор идва като правило от протокол, тогава той трябва да използва запазената дума `required` при всяка имплементация в някои тип данни.

#### Как да ограничим наследяването

Можем да използваме запазената дума `final` като модификатор на функция или клас. Ако маркираме клас, тогава няма да можем да го наследим. Това означава, че ограничаваме йерархията. 

Ако я изпозлваме върху метод, тогава няма да можем да го предифинираме в нито един от наследниците.
