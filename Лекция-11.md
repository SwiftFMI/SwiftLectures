# Грешки (Errors) в Swift

Без значение колко добър е, обработката и справянето с грешки е често срещана задача за всеки програмист. Въпреки че имаме пълен контрол над кода, който пишем и функционалностите, които създаваме, не можем да контролираме всичко в нашата програма и може да възникнат неочаквани резултати и събития. Това, което не можем да контролираме е начинът по който потребителят работи с нашата програма или дали необходимите ни ресурси са налични. В тази лекция ще разгледаме начините в Swift да се справяме с такива ситуации и възникналите грешки.

## Условия за възникване на грешки

В Swift определението за грешка е:

	...неуспешна проверка на даден израз, която води до отклонение в нормалното изпълнение на нашия код.
	
Според условията за възникването си, грешките попадат в една от три категории:

* Логически
* Прости
* Възвратими

### Логически грешки

Логическите грешки възникват в резултат от кода, който пишем. Тази категория за грешка включва неща като случайно извикване на функция на променлива, която смятаме, че съдържа обект, а всъщност е **nil** или се опитваме да достъпим елемент в колекция, използвайки индекс извън обхвата. В повечето случаи Swift (с помощта на компилатора) прави всичко възможно, за да ни помогне да избегнем тези видове грешки, но тази система не е перфектна и в тези грешки обикновено водят до краш.

### Прости грешки

Простите грешки възникват в резултат на извършване на някаква операция, която може да се провали по очевиден начин. Условията за грешка в тази категория обикновено са прости по своята същност и поради това те обикновено са лесно разбираеми и обикновено не се нуждаят от много допълнителна информация (ако има такава), за да се разбере какво се е случило. 

Конвертирането на **String** в **Int** е един такъв пример:

```swift
let value: Int? = Int ("1") // 1
let value2: Int? = Int ("Здравейте") // nil
``` 

Стойността на **String** може да се преобразува в **Int** или да не. Няма междинни случаи и не ни е необходима допълнителна информация, за да разберем какво се е случило. В Swift обикновено се справяме с простите грешки, като използваме **Optional** - връщане на желаната стойност при успех или **nil** в случай на грешка.

### Възвратими грешки

Последната категория грешки са възвратимите грешки, които възникват в резултат на операции, които се провалят по не толкова очевиден начини и ни е необходима допълнителна информация. Да вземе например четенето на файл от файловата система:

```siwft
func contentsOf(file filename: String) -> String? {
    // ...
}
```

Въпреки че резултатът от функцията е дефиниран като **Optional** (String?), има много причини, поради които четенето от диска може да се провали -  файлът не съществува, нямаме права да го достъпим, има грешен формат и т.н. Въпреки че можем да определим дали функцията е изпълнена успешно по резултата, ни е необходим информация да диагностицираме условията за грешката и как да се справим с нея. Трябва ни механизъм, който да използваме, за да капсулираме тази допълнителна информация. Swift предоставя няколко начина за решаване на проблема, но първо да разгледаме как се представят грешките в Swift.

## Error протоколът

В Swift грешките са стойности, които имплементират **Error** протокола. Това е празен протокол, който няма функции или пропъртита. За да дефинираме грешка, е необходимо да създадем свой собствен тип, който имплементира протокола. Въпреки че този тип може да е всякакъв, в практиката най-често се използват Изброените типове. Например:

```swift
enum FileError: Error {
	case notFound
	case permissionDenied
	case unknownFormat
}
```

В този пример грешката, която ще обработваме ще е от тип **FileError** и има следните случаи - файлът не съществува (**.notFound**), нямаме права да го достъпим (**.permissionDemied**) и непознат формат или неподдържан (**.unknownFormat**).

Можем да използваме и Изброени типове с асоциирани стойности, за да предаваме допълнителната информация от грешката.

След като вече знаем как да различаваме възникналата грешка, ни е необходим начин да я предаваме като резултат от нашата функция. Това може да се направи чрез *резултатен* тип.

### Резултатни типове (Result types)

Да вземем за пример **Optional**:

```swift
enum Optional<Wrapped> {
	case none
	case some(Wrapped)
}
```
Резултатните типове са много подобни - шаблонен Изброен тип с два възможни случая: 

* неуспех с асоциирана стойност обект от тип, който имплементира **Error** протокола  
* успех с асоциирана стойност обект от очаквания тип

```swift
enum ResultType<T> {
	case failure(Error)
	case success(T)
}

```

Прилагайки идеята към горния пример:

```swift
func contentsOf(file filename: String) -> String? {
    // ...
}

```

Вместо функция, която връща **Optinal**, за да покаже успех или неуспех при четене на файл, можем да я предефинираме като функция, която връща нашия **ResultType** със съответната информация за грешка или символния низ.

```swift
func contentsOf(file filename: String) -> ResultType<String> {
    //...
}
```

Така дефинирана нашата функция, която използва **ResultType**, всеки път, когато я използваме може да обработваме резултата или грешката по следния начин:

```swift
let filename = "source.txt"
let result = contentsOf(file: filename)

switch result {
case .success(let content):
    print(content)
case .failure(let error):
    switch error {
    case FileError.notFound:
        print("Unable to find file \(filename).")
    case FileError.permissionDenied:
        print("You do not have permission to access the file \(filename).")
    case FileError.unknownFormat:
        print("Unable to open file \(filename) - incompatible format.")
    default:
        print("Unknown error")
    }
}
```

Обърнете внимание на **default** клаузата в switch-a. Всеки switch оператор в Swift трябва да е изчерпателен, затова обработваме *всички* грешки, които имплементират протокола **Error**. Можем обаче да добавим допълнителни ограничения, за да си го спестим, като добавим втори шаблонен тип при неуспех:

```swift
enum ResultType<T, E> {
	case failure(E)
	case success(T)
}

func contentsOf(file filename: String) -> ResultType<String, FileError> {
    //...
    return .failure(.notFound)
}
```

## Хвърляне на грешки чрез throw

В Swift можем да окажем, че в една функция или клоужър е възникнала грешка чрез запазената дума **throw**. Така използваме вградения механизъм за обработка на грешки. Хвърлянето на грешка е същото като връщане на резултат неуспех (например **.failure(.notFound)**), позволявайки ни също да прикачим допълнителна информация. Използваме **throw** оператора, следван от обект, който имплементира **Error** протокола.

```swift
throw FileError.notFound
```

Грешката може да се хвърли по време на изпълнение в тялото на функция или клоужър. При извикване на **throw** оператора, изпълнението на функцията спира веднага (подобно на **return**) и грешката се прехвърля към обкръжаващия блок (scope).

Обработването на грешката може да се извърши в извикващата функция или да се предаде нагоре по веригата.

### Предаване на грешката чрез throws

В Swift дали една функция хвърля грешка е част от нейната дефиниция. По подразбиране функциите в Swift *не* хвърлят и не мога да предават грешки. Това означава, че в общия случай ако възникне грешка в тялото на функцията, трябав да я прихванем и обработим. Понякога не можем (нямаме достатъчно информация) или не е логично да обработим грешката в текущата функция, като тогава е необходимо да я предадем нагоре по веригата. За да окажем, че една функция може да предава грешки, използваме запазената дума **throws** към дефиницията на функцията. Тогава казваме, че тази функция прехвърля (**rethrows**) или предава грешките, възникнали по време на нейното изпълнение. Запазената дума се записва след списъка с параметри на функцията и преди стрелката за връщане (->):

```swift
func contentsOf(file filename: String) throws -> String {
    //...
}
```

### Извикване на хвърлящи/предаващи функции

От дефиницията на горната функция става ясно, че тя хвърля грешка по време на изпълнението си. От гледна точка на извикването й обаче нещата не изглеждат толкова ясни на пръв поглед:

```swift
let content = contentsOf(file: "test.txt")
```

От тук няма как да сме сигурни дали извиканата функция хвърля грешка или не. Тук на помощ идва компилаторът, който ни предупреждава и изисква да добавим като префикс запазената дума **try** (**try?** или пък **try!**) преди извикването на функцията.

```swift
let content = try contentsOfFile(file: "test.txt")
```
Добавянето на **try** извършва две функции - сигнализира на компилатора, че извикваме функция, която може да предава грешка; а на четящия кода става ясно, че извикваната функция хвърля грешка, която трябва да се обработи.

### Предаване на грешките чрез rethrows

Да вземем за пример функция **log**, която изписва съобщения (в случая в конзолата).

```swift
func log(description: () -> String) {
	print(description())
}
```

Така записана, функцията е напълно валидна и работеща, но ако си представим, че клоужъра **description** може да хвърля грешки, то самата функция **log** може да ги обработва или да ги предава за обработка на извикващия чрез **rethrows**. В Swift **rethrows** се използва за функции, които хвърлят грешка когато и само когато някой от параметрите й хвърля грешка:

```swift
func log(description: () throws -> String) rethrows -> () {
    print(try description())
}

func nonThrowing() -> String {
    return "Hello"
}

enum LogError : Error {
    case someError
}

func throwing() throws -> String {
    //...
    throw LogError.someError
}

log(nonThrowing)
try log(throwing)
```

Първото извикване на функцията е с клоужър **nonthrowing**, който не хвърля грешки и тъй като използваме анотацията **rethrows**, цялата функция не би могла да хвърли грешка при извикването си. Затова не е необходим префикса **try**. При второто извикване на функцията с параметър **throwing**, имаме хвърляне на грешки и затова е необходим **try**.

Две важни неща за функциите с анотация **rethrows**:

1. Те **трябва** да имат поне един параметър, който е функция/клоужър, която да хвърля грешки (**throws**).
2. Те могат да предават само грешки, които са хвърляни от функциите, които получават като параметър, но сами по себе си не могат да хвърлят грешки

```swift
//1
func doSomething(completion: () -> String) rethrows -> String {
    return completion()
} 
// ERROR: 'rethrows' function must take a throwing function argument

//2
enum ExampleError : Error {
    case someError
    case someOtherError
}

func doSomethingElse(completion: () -> String) rethrows -> String {
    throw ExampleError.someError
}
// ERROR: a function declared 'rethrows' may only throw if its parameter does
```

## Обработка на грешките

В Swift можем да обработим грешките по един от три начина:

* Чрез **do-catch** оператора
* Използвайки **Optinal** стойност
* Прекратяване на изпълнението на програмата

### Обработка на грешките чрез do-catch оператора
В Swift **do** оператора създава нов блок (scope). Подобен е на къдравите скоби (**{}**) в **C**. Този блок е подобен на всеки друг, което означава, че в него можем да дефинираме променливи и константи, които ще бъдат достъпни само в този блок и ще са живи до края на блока дефиниран с **do**. В допълнение, **do** блокът може да съдържа един или повече **catch** оператора, като всеки **catch** съдържа израз, който може да бъде сравняван с очаквани грешки. Чрез **catch** *хващаме* хвърляните грешки от **throw** функциите:

```swift
do {
    try expression
}
catch errorPattern1 {
    statements
} 
catch errorPattern2 where condition {
    statements
} 
catch {
    statements
}
```

Можем да използваме **do-catch** в различните му форми и комбинации, за да обработваме различни грешки:

```swift
enum InputError : Error {
    case makeMissing
    case mileageTooLow(Int)
    case mileageTooHigh(Int)
}

func shouldBuyCar(make: String, mileage: Int) throws {
    guard !make.isEmpty else {
        throw InputError.makeMissing
    }

    switch mileage {
        case mileage where mileage < 10:
            throw InputError.mileageTooLow(mileage)
        case mileage where mileage > 100: 
            throw InputError.mileageTooHigh(mileage)
        default:
            print("Buy it!")
    }
}

do {
    try shouldBuyCar(make: "Honda", mileage:120)
}
catch InputError.makeMissing { // проверяваме за конкретна грешка
    print("Missing make")
}
catch let InputError.mileageTooHigh(x) where x > 150 { // асоциирани стойности и допълнителни условия
    print("Mileage way way too high...")
}
catch let InputError.mileageTooHigh(x) { // асоциирани стойности
    print("Mileage too high")
}
catch { // хващаме всички останали грешки.
    print("\(error)")
}

// Mileage too high

```

Обърнете внимание на сравняването на типа грешка и използването на асоциирана стойност.

	При използване на catch без условия, по подразбиране получаваме обект error от тип Error!

### Конвертиране на грешките към Optional чрез try?

Освен `do-catch` оператора, в Swift може да използваме **try?** оператора, за да получим резултата от функцията или **nil** при грешка:

```swift
func throwing() throws -> String {
    // ...
}

let result = try? throwing() // -> String?
```

Недостатъкът на този подход е, че губим допълнителната информация, асоциирана с грешката.

### Прекратяване на програмата при грешка чрез try!

Последният начин за обработване на грешките в Swift е чрез оператора **try!**. Той е много по-задължаващ от **try** и **try?**. Използваме го, когато *знаем*, че функцията, която пишем не би трябвало да хвърля грешка при изпълнението си, въпреки че е маркирана с **throw**. Например при предварително валидирани потребителски данни, при които сме сигурни, че няма грешка.

```swift
enum ValueError : Error {
    case negativeValue
}

func squarePositive(value: Int) throws -> Int {
    guard value >= 0 else {
        throw ValueError.negativeValue
    }
    
    return value * value
}

let output : Int
let input = 10
if input >= 0 {
    output = try! squarePositive(value: input)
    print(output)
}
```
